#include <Arduino.h>
#include <SoftwareSerial.h>
// 4Digit&segment Display
//#include <TM1637Display.h>
#include "SevenSegmentTM1637.h"
#include "SevenSegmentExtended.h"
const byte PIN_CLK = 8;   // define CLK pin (any digital pin)
const byte PIN_DIO = 9;   // define DIO pin (any digital pin)
SevenSegmentExtended      display(PIN_CLK, PIN_DIO);

//TM1637Display display(CLK, DIO);
const unsigned int clockSpeed = 1000;    // speed up clock for demo 65
unsigned long lastTime = 0;
unsigned long lastTimeMode = 0;
unsigned long roundTime = 0;
int seconds = 60;
int minutes = 5;
int count = 5;
int twoRound = 2;

bool isTwoRound = false;
bool isStart = false;
bool isFinish = false;
bool isMode = false;
bool isModeStart = false;
bool isSound = false;
bool isSoundTwoR = false;
bool isSTR = false;
bool isSFinish = false;
bool startTime =false;
// mp3Play
#define ARDUINO_RX 5//should connect to TX of the Serial MP3 Player module
#define ARDUINO_TX 6//connect to RX of the module
SoftwareSerial mySerial(ARDUINO_RX, ARDUINO_TX);//init the serial protocol, tell to myserial wich pins are TX and RX
///////////////////////////////////////////////////////////////////////////////////
//all the commands needed in the datasheet(http://geekmatic.in.ua/pdf/Catalex_MP3_board.pdf)
static int8_t Send_buf[8] = {0} ;//The MP3 player undestands orders in a 8 int string
                                 //0X7E FF 06 command 00 00 00 EF;(if command =01 next song order)
#define NEXT_SONG 0X01
#define PREV_SONG 0X02

#define CMD_PLAY_W_INDEX 0X03 //DATA IS REQUIRED (number of song)

#define VOLUME_UP_ONE 0X04
#define VOLUME_DOWN_ONE 0X05
#define CMD_SET_VOLUME 0X06//DATA IS REQUIRED (number of volume from 0 up to 30(0x1E))
#define SET_DAC 0X17
#define CMD_PLAY_WITHVOLUME 0X22 //data is needed  0x7E 06 22 00 xx yy EF;(xx volume)(yy number of song)

#define CMD_SEL_DEV 0X09 //SELECT STORAGE DEVICE, DATA IS REQUIRED
                #define DEV_TF 0X02 //HELLO,IM THE DATA REQUIRED

#define SLEEP_MODE_START 0X0A
#define SLEEP_MODE_WAKEUP 0X0B

#define CMD_RESET 0X0C//CHIP RESET
#define CMD_PLAY 0X0D //RESUME PLAYBACK
#define CMD_PAUSE 0X0E //PLAYBACK IS PAUSED

#define CMD_PLAY_WITHFOLDER 0X0F//DATA IS NEEDED, 0x7E 06 0F 00 01 02 EF;(play the song with the directory \01\002xxxxxx.mp3

#define STOP_PLAY 0X16

#define PLAY_FOLDER 0X17// data is needed 0x7E 06 17 00 01 XX EF;(play the 01 folder)(value xx we dont care)

#define SET_CYCLEPLAY 0X19//data is needed 00 start; 01 close

#define SET_DAC 0X17//data is needed 00 start DAC OUTPUT;01 DAC no output
////////////////////////////////////////////////////////////////////////////////////

class MultiButton {
  public:

    MultiButton(int pin) {
      _pin = pin;
      _lastTransition = millis();
      _state = StateIdle;
      _new = false;
      pinMode(_pin, INPUT);
    }


    void update() {
      bool pressed = digitalRead(_pin);
      _new = false;


      if (!pressed && _state == StateIdle) {
        return;
      }


      unsigned int now = millis();
      int diff = now - _lastTransition;

      State next = StateIdle;
      switch (_state) {
        case StateIdle:                next = _checkIdle(pressed, diff);                break;
        case StateDebounce:            next = _checkDebounce(pressed, diff);            break;
        case StatePressed:             next = _checkPressed(pressed, diff);             break;
        case StateClickUp:             next = _checkClickUp(pressed, diff);             break;
        case StateClickIdle:           next = _checkClickIdle(pressed, diff);           break;
        case StateSingleClick:         next = _checkSingleClick(pressed, diff);         break;
        case StateDoubleClickDebounce: next = _checkDoubleClickDebounce(pressed, diff); break;
        case StateDoubleClick:         next = _checkDoubleClick(pressed, diff);         break;
        case StateLongClick:           next = _checkLongClick(pressed, diff);           break;
        case StateOtherUp:             next = _checkOtherUp(pressed, diff);             break;
      }
      //Serial.print("next:");
      //Serial.println(next);
      //Serial.print("_state:");
      //Serial.println(_state);
      if (next != _state) {

        _lastTransition = now;
        // Enter next state
        _state = next;

        _new = true;
      }
    } // END UPDATE


    bool isClick() const {
      return _new && (_state == StatePressed || _state == StateDoubleClick);
    }


    bool isSingleClick() {
      return _new && _state == StateSingleClick;
    }


    bool isDoubleClick() {
      return _new && _state == StateDoubleClick;
    }

    bool isLongClick() {
      return _new && _state == StateLongClick;
    }

    bool isReleased() {
      return _new && (_state == StateClickUp || _state == StateOtherUp);
    }

  private:
    static const int DEBOUNCE_DELAY    =  70; // ms
    static const int SINGLECLICK_DELAY = 250; // ms
    static const int LONGCLICK_DELAY   = 2000; // ms
    int _pin;

    enum State {
      StateIdle,
      StateDebounce,
      StatePressed,
      StateClickUp,
      StateClickIdle,
      StateSingleClick,
      StateDoubleClickDebounce,
      StateDoubleClick,
      StateLongClick,
      StateOtherUp,
    };

    unsigned int _lastTransition;
    State _state;
    bool _new;

    State _checkIdle(bool pressed, int diff) {
      (void)diff;
      // Wait for a key press
      return pressed ? StateDebounce : StateIdle;
    }

    State _checkDebounce(bool pressed, int diff) {

      if (!pressed) {
        return StateIdle;
      }
      if (diff >= DEBOUNCE_DELAY) {

        return StatePressed;
      }
      return StateDebounce;
    }

    State _checkPressed(bool pressed, int diff) {
      Serial.println("--- Pressed");

      if (!pressed) {
        return StateClickUp;
      }

      if (diff >= LONGCLICK_DELAY) {
        return StateLongClick;
      }
      return StatePressed;
    }

    State _checkClickUp(bool pressed, int diff) {
      (void)pressed;
      (void)diff;
      return StateClickIdle;
    }

    State _checkClickIdle(bool pressed, int diff) {
      if (pressed) {
        return StateDoubleClickDebounce;
      }
      if (diff >= SINGLECLICK_DELAY) {
        return StateSingleClick;
      }
      return StateClickIdle;
    }

    State _checkSingleClick(bool pressed, int diff) {
      (void)pressed;
      (void)diff;
      return StateIdle;
    }

    State _checkDoubleClickDebounce(bool pressed, int diff) {
      if (!pressed) {
        return StateClickIdle;
      }
      if (diff >= DEBOUNCE_DELAY) {
        return StateDoubleClick;
      }
      return StateDoubleClickDebounce;
    }

    State _checkDoubleClick(bool pressed, int diff) {
      (void)diff;
      if (!pressed) {
        return StateOtherUp;
      }
      return StateDoubleClick;
    }

    State _checkLongClick(bool pressed, int diff) {
      (void)diff;
      if (!pressed) {
        return StateOtherUp;
      }
      return StateLongClick;
    }

    State _checkOtherUp(bool pressed, int diff) {
      (void)pressed;
      (void)diff;
      return StateIdle;
    }
};



MultiButton startBtn(2);
MultiButton resetBtn(3);
MultiButton modeBtn(4);

void sendCommand(int8_t command, int16_t dat)
{
 delay(20);
 Send_buf[0] = 0x7e; //starting byte
 Send_buf[1] = 0xff; //version
 Send_buf[2] = 0x06; //the number of bytes of the command without starting byte and ending byte
 Send_buf[3] = command; //
 Send_buf[4] = 0x00;//0x00 = no feedback, 0x01 = feedback
 Send_buf[5] = (int8_t)(dat >> 8);//datah
 Send_buf[6] = (int8_t)(dat); //datal
 Send_buf[7] = 0xef; //ending byte
 for(uint8_t i=0; i<8; i++)//
 {
   mySerial.write(Send_buf[i]) ;//send bit to serial mp3
   Serial.print(Send_buf[i],HEX);//send bit to serial monitor in pc
 }
 Serial.println();
}


//
void timeBack(){
  if (millis() - lastTime  > 1000) {
    //Serial.println(lastTime);
    if (count - minutes == twoRound) { isTwoRound = true;}

    if ((seconds < 0)&&(minutes != 0)) {
      seconds = 60 - 1;
      minutes--;

    } else if (minutes == 0) {
      // set time
      startTime = false;
      isFinish = true;

    } else{
      if (seconds == 60) {seconds--;}
      display.printTime(minutes - 1, seconds, true);
    isStart = true;
    lastTime = millis();
    seconds--;
    }


  }

}
//
void setup() {
  Serial.begin(9600);
  mySerial.begin(9600);//Start our Serial coms for THE MP3
  delay(500);//Wait chip initialization is complete
  sendCommand(CMD_SEL_DEV, DEV_TF);//select the TF card
  delay(200);//wait for 200ms
  //display.setBrightness(7);
  display.begin();            // initializes the display
  display.setBacklight(100);  // set the brightness to 100 %
  display.printTime(minutes, 0, true);
  //delay(500);
}

void loop() {

startBtn.update();
resetBtn.update();
modeBtn.update();

// Time
if (startTime == true){
  timeBack();
}


//Sound Folder 2, two min.
if((startTime == true)&&(isSound == false)&&(isTwoRound == false)){
  if (millis() - lastTime  > 1000) {
  isSound = true;
  Serial.println("SoundFoulder #2");
  sendCommand(PLAY_FOLDER, 0x0201);
}
}

//Two Round and SOund Folder 4
if((startTime == true)&&(isSoundTwoR == false)&&(isTwoRound == true)){
  if ((isSTR == false)) {
    Serial.println("SONG FOULDER #3 : Round Two");
    sendCommand(PLAY_FOLDER, 0x0301);
    roundTime = millis();
      isSTR = true;
    }

  if (millis() - roundTime  > 2000) {
  isSoundTwoR = true;
  Serial.println("SoundFoulder #4");
  sendCommand(PLAY_FOLDER, 0x0401);
}
}

// Sound FInish folder 5
if ((isFinish == true)&&(isSFinish == false)){

  if (millis() - lastTime  > 1000) {
    isSFinish = true;
    Serial.println("SoundFoulder #5 Finished");
    sendCommand(CMD_PLAY_WITHFOLDER, 0x0501);
    delay(1000);
}
}

// Pressed START
if ((startBtn.isSingleClick())&&(startTime == false)&&(isModeStart == false)) {
  // digitalWrite(13,HIGH);
  Serial.println("START");
  if ((minutes == count)&&(seconds == 60)){
    sendCommand(CMD_PLAY_WITHVOLUME, 0X0F01);delay(1000);
  } else {sendCommand(CMD_PLAY, 0);}
  startTime = true;
}

// Pressed PAUSED
if ((startBtn.isSingleClick())&&(isStart == true)) {
  Serial.println("PAUSE");
  sendCommand(CMD_PAUSE, 0);

  isStart = false;
  startTime = false;

}

//Pressed MoDE
if ((startBtn.isSingleClick())&&(startTime == false)&&(isModeStart == true)) {
  minutes = count;

  isModeStart = false;
  isMode = false;

  display.printTime(minutes, 0, true);
  display.blink();
}

if ((modeBtn.isSingleClick())&&(isMode == false)) {
  Serial.println("MODE");

  //display.blink();
  if(isStart == false) {
    display.printTime(count, 0, true);
    isMode = true;

  }
}

if ((modeBtn.isSingleClick())&&(isModeStart == true)) {
  Serial.println("MODE SET");
if (count < 30){
  count = count + 5;
} else {count = 5;}
display.printTime(count, 0, true);
//display.blink();
}

if (isMode){
  if (millis() - lastTimeMode > 1000){
    Serial.print("isModeStart:");
    Serial.println(isModeStart);
    isModeStart = true;
  }


}

//Pressed RESET
if (resetBtn.isSingleClick()) {
  Serial.println("RESET");
  //sendCommand(CMD_RESET, 0);
  sendCommand(STOP_PLAY, 0);
  isStart = false;
  startTime = false;
  isFinish = false;
  isSound = false;
  isSoundTwoR = false;
  isSFinish = false;
  isSTR = false;
  isTwoRound = false;
  seconds = 60;
  minutes = count;
  display.blink();
  display.printTime(minutes, 0, true);
}



//while(1);
}// loop
